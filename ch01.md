# 动态链接库Hello-World

## 安装ObjectARX SDK

- 官网下载对应版本的安装包
- 安装到本地自行确定的位置
- 以下以objectarx2018为例

## 创建项目

- 在Visual Studio 2022中新建c++ dll项目

## 项目配置
- 打开项目属性
- 常规
  - 平台工具集->Visual Studio 2017(v141)
  - Windows SDK版本->10.0.19
  - 目标文件扩展名->`.arx`
- VC++目录->包含目录
  - `objectarx2018/inc/`
  - `objectarx2018/inc-x64/`
- VC++目录->包含目录
  - `objectarx2018/lib-x64`
- 链接器->输入->附加依赖项
  - acad.lib
  - acdb22.lib
  - acge22.lib
  - ac1st22.lib
  - rxapi.lib
  - accore.lib
- 链接器->输入->模块定义文件
  - 设置为和源文件中同名的.def文件

## 入口程序

- 项目默认以dllmain.cpp作为入口程序
- 编译的dll库作为AutoCad的插件安装
- 接口函数为acrxEntryPoint

> 示例程序

```cpp
#include "pch.h"
#include "rxregsvc.h"
#include "aced.h"
#include "tchar.h"

void InitApplication();
void UnloadApplication();
void Hello();

extern "C" AcRx::AppRetCode acrxEntryPoint(
    AcRx::AppMsgCode msg, void* appId)
{
    switch (msg) {
    case AcRx::kInitAppMsg:
        acrxDynamicLinker->unlockApplication(appId);
        acrxDynamicLinker->registerAppMDIAware(appId);
        InitApplication();
        break;
    case AcRx::kUnloadAppMsg:
        UnloadApplication();
        break;
    default:
        break;
    }
    return AcRx::kRetOK;
}

void Hello() {
    acedPrompt(_T("\nHello World"));
}

void InitApplication() {
    acedRegCmds->addCommand(_T("Exam01"), _T("Hello"), _T("你好"), ACRX_CMD_MODAL, Hello);
}

void UnloadApplication() {
    acedRegCmds->removeGroup(_T("Exam01"));
} 
```

## 添加def文件

- C++ DLL项目中配置.def文件用来显示指定DLL导出的函数
  - .def 文件列出 DLL 导出的函数名和序号，确保这些函数可供外部调用
  - 可以精确控制导出的函数名和序号，避免编译器自动导出所有符号
  - 某些情况下，使用 .def 文件能更好地兼容不同编译器或平台
  
```def
LIBRARY Exam01

EXPORTS

acrxEntryPoint	PRIVATE
acrxGetApiVersion PRIVATE
```

## 使用项目

- 点击生成
- 打开AutoCad2018新建图纸
- 在命令行中输入AP
- 安装刚刚生成的.arx文件
- 测试命令`HELLO`和`你好`
